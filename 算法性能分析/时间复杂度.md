## 时间复杂度

**时间复杂度是一个函数，它定性描述算法的运行时间。**

在软件开发中，时间复杂度用来方便开发者估算出程序运行的大体时间。

通常会估算**算法的操作单元数量**来代表程序消耗的时间，一般默认CPU每个单元运行消耗的时间是相同的。

假设算法问题的规模为n，那么操作单元数量用f(n)表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称为算法的渐进时间复杂度，简称时间复杂度，记为O(f(n))。



### 什么是大O

**大O用来表示上界**。当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

我们主要关心的还是**一般情况下的数据形式**的算法复杂度，大O并不代表严格的上界。

> **插入排序：**一般情况O(n^2)
>
> ​	在数字本来有序的情况下，即最好情况O(n)；
>
> ​	在数据本来逆序的情况下，即最坏情况O(n^2)。
>
> **快速排序：**一般情况O(nlogn)
>
> ​	在数据本来有序的情况下，即最坏情况O(n^2)。
>
> ​	但还是认为快速排序的时间复杂度为O(nlogn)。

### 不同数据规模的差异

使用算法时，并不是时间复杂度越低越好（因为简化后的时间复杂度**忽略了常数项**等等）。

要考虑**数据规模**，如果数据规模很小，可能O(n^2)的算法比O(n)的更合适（在有常数项时候）。

**大O是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量下常数项系数已经不起决定性作用。**

一般来说时间复杂度都是省略常数项系数的，<u>默认数据规模足够大</u>。

> **O(1)常数阶＜O(logn)对数阶<O(n)线性阶<O(n^2)平方阶<O(n^3)立方阶<O(2^n)指数阶**

但是也要注意大常数，假如常数项非常大，例如10^9等，那么常数就是不得不考虑的因素了。

### 复杂表达式的化简

时间复杂度常常不是简单的表达式，可能是一个复杂的表达式。

简化的方法为：

- 去掉运行时间中的加法常数项
- 去掉常数系数
- 只保留最高项，去掉数量级小一级的n

### 对数项时间复杂度中的log以什么为底？

平时算法的时间复杂度的对数项**不一定是以2为底**的，可以是任意底数。

但统一说logn，也就是**忽略底数**。

假如两个算法的时间复杂度，分别是log以2位底n的对数和log以10为底n的对数，不难理解`以2为底n的对数 = 以2位底10的对数 * 以10为底n的对数`，而其中`以2为底10的对数`可以作为常数项忽略。因此可以忽略底数。

### 写个测试程序看看——测1s内程序处理多大量级数据

程序运算时间受到很多因素影响：

- CPU执行每条指令所需的时间实际上并不相同，例如加法和乘法操作的耗时实际上不同。
- 现在大多计算机系统的内存管理都有缓存技术，所以频繁访问相同地址的数据和访问不相邻的元素所需时间也不同。
- 计算机同时运行多个程序，可能有不同的进程线程在抢占资源。

所以只能对程序的运行时间有一个大体的评估。

实现三个函数，时间复杂度分别是O(n)、O(n^2)、O(logn)，使用加法运算来统一测试，得出在个人PC上测出来的数据。

```java
import java.util.Scanner;

/**
 * @author zkc
 * @create 2022-06-24
 */
public class TimeComplexityTest {
    public static void main(String[] args) {
        while (true) {
            Scanner in = new Scanner(System.in);
            System.out.print("输入n:");
            long n = in.nextLong();
            long startTime = System.currentTimeMillis();

            function1(n);
            // function2(n);
            // function3(n);

            // 记录耗时
            long endTime = System.currentTimeMillis();
            long costTime = endTime - startTime;
            System.out.println("算法耗时：" + costTime + "ms");
        }
    }

    // O(n)
    public static void function1(long n) {
        System.out.print("O(n)算法,");
        long k = 0;
        for (long i = 0; i < n; i++) {
            k++;
        }
    }

    // O(n^2)
    public static void function2(long n) {
        System.out.print("O(n^2)算法,");
        long k = 0;
        for (long i = 0; i < n; i++) {
            for (long j = 0; j < n; j++) {
                k++;
            }
        }
    }

    // O(logn)
    public static void function3(long n) {
        System.out.print("O(logn)算法,");
        long k = 0;
        for (long i = 0; i < n; i++) {
            for (long j = 1; j < n; j*=2) {
                k++;
            }
        }
    }
}
```

function1函数O(n)算法的运行结果，大概为**3*(10^9)次**。

```
输入n:100000000
O(n)算法,算法耗时：38ms
输入n:3000000000
O(n)算法,算法耗时：994ms
```

function2函数O(n^2)算法的运行结果，大概为**5*(10^4)次**。

```
输入n:10000
O(n^2)算法,算法耗时：41ms
输入n:50000
O(n^2)算法,算法耗时：1577ms
输入n:48000
O(n^2)算法,算法耗时：910ms
```

function3函数O(logn)算法的运行结果，大概为**4.5*(10^7)次**。

```
输入n:5000000
O(logn)算法,算法耗时：51ms
输入n:100000000
O(logn)算法,算法耗时：2376ms
输入n:45000000
O(logn)算法,算法耗时：1050ms
```

### 递归算法的时间复杂度

递归算法的时间复杂度本质上要看：**递归的次数 * 每次递归中的操作次数**。
