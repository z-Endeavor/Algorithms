# 4-长度最小的子数组

**滑动窗口**是数组操作中一个重要的方法。滑动窗口就是不断的调节子序列的起始位置和终止位置，从而得到想要的结果。

运用滑动窗口，需要确定<u>窗口内是什么</u>和<u>如何移动窗口的起始位置和结束位置</u>。

由于可以根**据当前子序列和大小的情况，不断调节子序列的起始位置**，可以将暴力解法的O(n^2)时间复杂度降为O(n)。

> 虽然通常代码中有两个循环（一个for，一个while），但是**主要看每一个元素被操作的次数**。每一个元素在滑动窗口中进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是2 x n 还是O(n)。

**相关题目：**

- [209.长度最小的子数组]: #长度最小的子数组

- [904.水果成篮]: #水果成篮

  



209. ## 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组[4,3]是该条件下的长度最小的子数组。
```

**示例2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。



### 思路

暴力解法需要使用两个循环遍历所有子数组的情况，时间复杂度为O(n^2)，不符合题意。

因此使用滑动窗口方法。

#### 滑动窗口

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 定义子数组长度，元素之和以及滑动窗口的起始位置
        int len = Integer.MAX_VALUE, sum = 0, index = 0;
        for (int i=0; i<nums.length; i++) {
            // 移动结束位置，延长子数组直到大于目标值
            sum += nums[i];
            // 移动起始位置，找到符合要求的长度最小的子数组
            while (sum >= target) {
                len = Math.min(len, i-index+1);
                sum -= nums[index++];
            }
        }
        return len == Integer.MAX_VALUE ? 0 : len;
    }
}
```





904. ## 水果成篮

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例1：**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例2：**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例3：**

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例4：**

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

**提示：**

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`



### 思路

#### 滑动窗口

本题目也需要根据**子序列的情况来找到最优解**，因此也可以使用滑动窗口求解。属于滑动窗口中的计数问题。

根据题目`0 <= fruits[i] < fruits.length`的提示，目前每一种水果的数量可以用一个和已知数组长度相同的数组num来记录。

num数组记录当前滑动窗口中两种水果的数量，保证当前滑动窗口中最多只有两种水果。

```java
class Solution {
    public int totalFruit(int[] fruits) {
        // 定义水果种类，总计数以及滑动窗口的起始位置
        int count = 0, sum = 0, index = 0;
        // 定义记录窗口内两种水果数目的数组
        int[] num = new int[fruits.length];

        // 移动滑动窗口的结束边界
        for (int i=0; i<fruits.length; i++) {
            // 更新num数组。如果水果种类在滑动窗口内是新种类，则直接增加计数
            if ((++num[fruits[i]]) == 1) {
                count++;
            }
            // 如果计数不超过两种水果，则滑动窗口的结束边界一直向后移动。
            // 如果计数超过两种水果，则需要调整滑动窗口的起始边界，并更新num数组。直到该水果在窗口内的数量变为0，减少计数。
            while (count > 2) {
                if ((--num[fruits[index]]) == 0) {
                    count--;
                }
                index++;
            }
            // 记录最大计数的滑动窗口
            sum = Math.max(sum, i-index+1);
        }

        return sum;
    }
}
```

