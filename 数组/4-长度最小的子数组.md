# 4-长度最小的子数组

**滑动窗口**是数组操作中一个重要的方法。滑动窗口就是不断的调节子序列的起始位置和终止位置，从而得到想要的结果。

运用滑动窗口，需要确定<u>窗口内是什么</u>和<u>如何移动窗口的起始位置和结束位置</u>。

由于可以根**据当前子序列和大小的情况，不断调节子序列的起始位置**，可以将暴力解法的O(n^2)时间复杂度降为O(n)。

> 虽然通常代码中有两个循环（一个for，一个while），但是**主要看每一个元素被操作的次数**。每一个元素在滑动窗口中进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是2 x n 还是O(n)。

**相关题目：**

- [209.长度最小的子数组]: #长度最小的子数组

  



209. ## 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组[4,3]是该条件下的长度最小的子数组。
```

**示例2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。



### 思路

暴力解法需要使用两个循环遍历所有子数组的情况，时间复杂度为O(n^2)，不符合题意。

因此使用滑动窗口方法。

#### 滑动窗口

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 定义子数组长度，元素之和以及滑动窗口的起始位置
        int len = Integer.MAX_VALUE, sum = 0, index = 0;
        for (int i=0; i<nums.length; i++) {
            // 移动结束位置，延长子数组直到大于目标值
            sum += nums[i];
            // 移动起始位置，找到符合要求的长度最小的子数组
            while (sum >= target) {
                len = Math.min(len, i-index+1);
                sum -= nums[index++];
            }
        }
        return len == Integer.MAX_VALUE ? 0 : len;
    }
}
```

