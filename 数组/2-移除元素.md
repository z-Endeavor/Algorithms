# 2-移除元素

数组的元素在内存地址中时连续的，不能单独删除数组中的某个元素，只能**覆盖**。

**双指针法**（快慢指针法）：通过一个**快指针**和**慢指针**在<u>一个for循环下完成两个for循环</u>的工作。

双指针法（快慢指针法）在数组和链表的操作中很常见，很多<u>数组、链表、字符串</u>等操作，都使用双指针法。

**相关题目**：

- [27.移除元素]: #移除元素

  



27. ## 移除元素

给你一个数组 nums 和一个值 val，你需要 **原地** 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 **修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「**引用**」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```java
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度，它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
	print(nums[i]);
}
```

**示例1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2，并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5，并且 nums 中的前五个元素为 0,1,3,0,4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`



### 思路

暴力解法就两层for循环，一个for循环遍历数组元素，第二个for循环更新数组元素和长度。时间复杂度为O(n^2)。

双指针法仅需一层循环即可实现，且不会改变数组元素的相对位置。

#### 双指针法

时间复杂度O(n)，空间复杂度O(1)。

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 慢指针，同时记录新数组长度
        int len = 0;
        // 快指针，作为循环变量遍历数组
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[len++] = nums[i];
            }
        }
        return len;
    }
}
```





26. ## 删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **原地 修改输入数组** 并在使用 O(1) 额外空间的条件下完成。



**判题标准**

系统会用下面的代码来测试你的题解:

```java
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

**示例1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **升序** 排列



### 思路

删除有序数组的重复项，本质与移除元素一样。

同时题目要求数组元素的<u>相对顺序保持一致</u>，则可以使用**双指针法**。

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        // 慢指针，同时作为存储新数组元素的下标
        int len = 0;
        // 循环变量作为快指针，判断是否有与新数组重复的元素。因为是升序数组，所以只需判断最后一个元素即可。
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[len]) {
                nums[++len] = nums[i];
            }
        }
        // 新数组长度为数组元素下标加一
        return len+1;
    }
}
```

