# 3-有序数组的平方

**相关题目：**

- [977.有序数组的平方]: #有序数组的平方





977. ## 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为[16,1,0,9,100]
	排序后，数组变为[0,1,9,16,100]
```

**示例2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

**进阶：**

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题



### 思路

题目要求使用时间复杂度O(n)的算法来解决问题，暴力解法（遍历平方后排序）的时间复杂度为O(n+nlogn) ，因此不可行。

导致<u>新数组的顺序发生混乱的原因是负数平方后可能会比正数更大</u>，所以在数组平方的**最大值会在数组的两端**。

因此使用双指针法，**从原数组的两端开始走，将更大的一个存入新数组的最后一位**，直到走完整个数组。

#### 双指针法

时间复杂度O(n)，空间复杂度O(n)。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 记录平方后最大元素放入新数组的下标位置
        int index = nums.length - 1;
        int[] arr = new int[nums.length];
        // 定义双指针从数组的两端进行遍历
        for (int i=0, j=nums.length-1; i<=j;) {
            // 选择平方后更大的元素从新数组的最后面开始存放
            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
                arr[index--] = nums[i] * nums[i];
                i++;
            } else {
                arr[index--] = nums[j] * nums[j];
                j--;
            }
        }
        return arr;
    }
}
```

